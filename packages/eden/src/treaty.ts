import type { AnyElysia, RouteSchema } from 'elysia'

import { EdenClient } from './client'
import type { TypeError } from './errors'
import { type HttpMutationMethod, type HttpQueryMethod, type HttpSubscriptionMethod } from './http'
import type { InferRouteBody, InferRouteOptions, InferRouteResponse } from './infer'
import { httpLink, type HTTPLinkOptions } from './links'
import { parsePathsAndMethod } from './path'
import {
  type ExtractEdenTreatyRouteParams as ExtractEdenTreatyRouteParameters,
  type ExtractEdenTreatyRouteParamsInput as ExtractEdenTreatyRouteParametersInput,
  getPathParam as getPathParameter,
} from './path-params'
import type { EdenRequestOptions } from './request'
import type { EdenRequestParams as EdenRequestParameters } from './resolve'
import type { EmptyToVoid } from './utils/empty-to-void'
import { isGetOrHeadMethod, isHttpMethod } from './utils/http'
import type { Optional } from './utils/optional'
import type { EdenWS } from './ws'

/**
 * RPC proxy derived from {@link AnyElysia._routes} for accessing an Elysia.js API.
 */
export type EdenTreatyClient<T extends AnyElysia> = T extends {
  _routes: infer TSchema extends Record<string, any>
}
  ? EdenTreatyHooksProxy<TSchema>
  : TypeError<'Please install Elysia before using Eden'>

/**
 * Recursively iterate over all keys in {@link AnyElyisa._routes}, processing path parameters
 * and regular path segments separately.
 *
 * Regular path parameters will be mapped to a nested object, and then intersected
 * with anything generated by dynamic path parameters.
 *
 * @template TSchema The current level of {@link AnyElysia._routes} being processed.
 * @template TPath The current path segments up to this point (excluding dynamic path parameters).
 * @template TRouteParams Keys that are considered path parameters instead of regular path segments.
 */
export type EdenTreatyHooksProxy<
  TSchema extends Record<string, any>,
  TPath extends any[] = [],
  TRouteParameters = ExtractEdenTreatyRouteParameters<TSchema>,
> = EdenTreatyPathHooks<TSchema, TPath, TRouteParameters> &
  EdenTreatyHooksPathParameterHook<TSchema, TPath, TRouteParameters>

/**
 * Recursively handle regular path segments (i.e. NOT path parameters).
 *
 * If the value is a {@link RouteSchema}, then it's a "leaf" that does not need to be
 * recursively processed. The result should be the key, an HTTP method, mapped to a
 * strongly-typed function.
 *
 * @template TSchema The current level of {@link AnyElysia._routes} being processed.
 * @template TPath The current path segments up to this point (excluding dynamic path parameters).
 * @template TRouteParams Keys that are considered path parameters instead of regular path segments.
 */
type EdenTreatyPathHooks<
  TSchema extends Record<string, any>,
  TPath extends any[] = [],
  TRouteParameters = ExtractEdenTreatyRouteParameters<TSchema>,
> = {
  [K in Exclude<keyof TSchema, keyof TRouteParameters>]: TSchema[K] extends RouteSchema
    ? EdenTreatyQueryRouteLeaf<TSchema[K], K>
    : EdenTreatyHooksProxy<TSchema[K], [...TPath, K]>
}

/**
 * {@link EdenTreatyHooksProxy} intersects the object created by {@link EdenTreatyPathHooks}
 * for regular path parameters with anything created by this type for dynamic path parameters.
 *
 * If there are no dynamic path parameters, then return an empty object.
 * Intersecting with empty object does nothing.
 *
 * Otherwise, return a function that returns the next level of the proxy, omitting
 * the current dynamic path parameter.
 *
 * @template TSchema The current level of {@link AnyElysia._routes} being processed.
 * @template TPath The current path segments up to this point (excluding dynamic path parameters).
 * @template TRouteParams Keys that are considered path parameters instead of regular path segments.
 */
type EdenTreatyHooksPathParameterHook<
  TSchema extends Record<string, any>,
  TPath extends any[] = [],
  TRouteParameters = {},
> = {} extends TRouteParameters
  ? {}
  : (
      parameters: ExtractEdenTreatyRouteParametersInput<TRouteParameters>,
    ) => EdenTreatyHooksProxy<TSchema[Extract<keyof TRouteParameters, keyof TSchema>], TPath>

/**
 * When a {@link RouteSchema} is found, map it to leaves and stop recursive processing.
 * Leaves are function calls that abstract the native {@link fetch} API.
 *
 * Based on the HTTP request "category", e.g. "query", "mutation", "subscription", or "unknown",
 * return the corresponding leaf.
 *
 * @template TRoute The {@link RouteSchema} that was found.
 * @template TMethod The most recent key that was mapped to the {@link TRoute}. e.g. "get", "post", etc.
 */
export type EdenTreatyQueryRouteLeaf<
  TRoute extends RouteSchema,
  TMethod,
> = TMethod extends HttpQueryMethod
  ? EdenTreatyQueryLeaf<TRoute>
  : TMethod extends HttpMutationMethod
    ? EdenTreatyMutationLeaf<TRoute>
    : TMethod extends HttpSubscriptionMethod
      ? EdenTreatySubscriptionLeaf<TRoute>
      : EdenTreatyUnknownLeaf<TRoute>

/**
 * Strongly-typed function for queries (i.e. "GET" requests).
 */
export type EdenTreatyQueryLeaf<TRoute extends RouteSchema> = (
  options: EmptyToVoid<Optional<InferRouteOptions<TRoute>, 'params'>>,
) => Promise<InferRouteResponse<TRoute>>

/**
 * Strongly-typed function for mutations (i.e. "POST", "PATCH", etc. requests).
 */
export type EdenTreatyMutationLeaf<TRoute extends RouteSchema> = (
  body: EmptyToVoid<InferRouteBody<TRoute>>,
  options: EmptyToVoid<Optional<InferRouteOptions, 'params'>>,
) => Promise<InferRouteResponse<TRoute>>

/**
 * Strongly-typed function for subscriptions (i.e. "CONNECT", "SUBSCRIBE", etc. requests).
 *
 * @TODO: Available hooks assuming that the route supports `createSubscription`.
 */
export type EdenTreatySubscriptionLeaf<TRoute extends RouteSchema> = (
  options: EmptyToVoid<Optional<InferRouteOptions<TRoute>, 'params'>>,
) => EdenWS<TRoute>

/**
 * Strongly-typed function for unknown request.
 *
 * @todo What should it actually be...
 */
export type EdenTreatyUnknownLeaf<TRoute extends RouteSchema> = EdenTreatyQueryLeaf<TRoute> &
  EdenTreatyQueryLeaf<TRoute> &
  EdenTreatyMutationLeaf<TRoute> &
  EdenTreatySubscriptionLeaf<TRoute>

/**
 * @param client
 *
 * @param config
 *
 * @param [paths=[]] Path parameter strings including the current path parameter as a placeholder.
 * @example [ 'products', ':id', ':cursor' ]
 *
 * @param [pathParams=[]] An array of objects representing path parameter replacements.
 * @example [ { id: 123 }, { cursor: '456' } ]
 */
export function createEdenTreatyProxy<T extends AnyElysia>(
  client: EdenClient<T>,
  config?: EdenRequestOptions<T>,
  paths: string[] = [],
  pathParameters: Record<string, any>[] = [],
) {
  const edenTreatyProxy = new Proxy(() => {}, {
    get: (_target, path: string, _receiver): any => {
      // Copy the paths so that it will not be mutated in a nested proxy.
      // Only add the current path if is not "index".
      const nextPaths = path === 'index' ? [...paths] : [...paths, path]

      //  Return a nested proxy that has the new paths.
      return createEdenTreatyProxy(client, config, nextPaths, pathParameters)
    },
    apply: (_target, _thisArgument, arguments_) => {
      // Parse the information from the paths array up to this point.
      const { path, method } = parsePathsAndMethod(paths)

      // Determine if the current args could be specifying dynamic path parameters.
      const pathParameter = getPathParameter(arguments_)

      // If it is a valid path parameter argument and the HTTP method is not recognized,
      // then return a nested proxy that includes the path parameter replacement.
      if (pathParameter?.key != undefined && !isHttpMethod(method)) {
        const allPathParameters = [...pathParameters, pathParameter.param]
        const pathsWithParameters = [...paths, `:${pathParameter.key}`]
        return createEdenTreatyProxy(client, config, pathsWithParameters, allPathParameters)
      }

      // Otherwise, assume that this is intended to be a request and handle it.

      let options: any
      let body: any

      if (isGetOrHeadMethod(method)) {
        options = arguments_[0]
      } else {
        body = arguments_[0]
        options = arguments_[1]
      }

      const parameters: EdenRequestParameters = {
        body,
        options,
        path,
        method,
        ...config,
      }

      return client.query(parameters)
    },
  })

  return edenTreatyProxy
}

/**
 * @param clientOrHttpLinkOptions Either an untyped {@link EdenClient} or options for an httpLink to initialize a default client.
 * @param options Request options.
 */
export function createEdenTreaty<T extends AnyElysia>(
  clientOrHttpLinkOptions?: EdenClient<T> | HTTPLinkOptions<T>,
  options?: EdenRequestOptions<T>,
): EdenTreatyClient<T> {
  if (clientOrHttpLinkOptions instanceof EdenClient) {
    const proxy = createEdenTreatyProxy(clientOrHttpLinkOptions, options)
    return proxy as any
  }

  const defaultClient = new EdenClient({ links: [httpLink(clientOrHttpLinkOptions)] })

  const proxy = createEdenTreatyProxy(defaultClient, options)
  return proxy as any
}
